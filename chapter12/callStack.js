const fun1 = () => {
  console.log("첫번째 함수");
};
const fun2 = () => {
  fun1();
  console.log("두번째 함수");
};
const fun3 = () => {
  fun2();
  console.log("세번째 함수");
};
// fun3();
// fun1();

/*
첫번째 함수
두번째 함수
세번째 함수
첫번째 함수
*/

console.log("콘솔로그");
fun3();

//내가 잘못 알고있었던 개념이 있기에 정리한다.
//콜스택상에 함수가 들어오면 자연스럽게 콜스택상에 쌓이고 쌓여서 스택자료구조의 특성대로 함수가 빠져나가는줄 알았다.
//하지만 함수가 들어오면 해당 함수의 동작을 마치고 함수내에 또다른 함수, 모듈들을 콜스택에 담는다. 즉, 콜스택에 들어온 함수내에 또 다르게 처리해야할 함수가 존재할때에만
//스택의 특성대로 함수가 빠져나가는 것이다.
//위에 예시를 보면 확실히 이해할 수 있다. 예상되는 동작은
/*
첫번째 함수
첫번째 함수
두번째 함수
세번째 함수
*/
//였지만 실제 동작은 첫번째 함수라는 출력이 맨 뒤에 동작한다. 